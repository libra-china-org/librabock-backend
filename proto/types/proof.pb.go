// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proof.proto

package types

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type AccumulatorProof struct {
	// The bitmap indicating which siblings are default. 1 means non-default and
	// 0 means default. The LSB corresponds to the sibling at the bottom of the
	// accumulator. The leftmost 1-bit corresponds to the sibling at the level
	// just below root level in the accumulator, since this one is always
	// non-default.
	Bitmap uint64 `protobuf:"varint,1,opt,name=bitmap,proto3" json:"bitmap,omitempty"`
	// The non-default siblings. The ones near the root are at the beginning of
	// the list.
	NonDefaultSiblings   [][]byte `protobuf:"bytes,2,rep,name=non_default_siblings,json=nonDefaultSiblings,proto3" json:"non_default_siblings,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccumulatorProof) Reset()         { *m = AccumulatorProof{} }
func (m *AccumulatorProof) String() string { return proto.CompactTextString(m) }
func (*AccumulatorProof) ProtoMessage()    {}
func (*AccumulatorProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{0}
}

func (m *AccumulatorProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccumulatorProof.Unmarshal(m, b)
}
func (m *AccumulatorProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccumulatorProof.Marshal(b, m, deterministic)
}
func (m *AccumulatorProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccumulatorProof.Merge(m, src)
}
func (m *AccumulatorProof) XXX_Size() int {
	return xxx_messageInfo_AccumulatorProof.Size(m)
}
func (m *AccumulatorProof) XXX_DiscardUnknown() {
	xxx_messageInfo_AccumulatorProof.DiscardUnknown(m)
}

var xxx_messageInfo_AccumulatorProof proto.InternalMessageInfo

func (m *AccumulatorProof) GetBitmap() uint64 {
	if m != nil {
		return m.Bitmap
	}
	return 0
}

func (m *AccumulatorProof) GetNonDefaultSiblings() [][]byte {
	if m != nil {
		return m.NonDefaultSiblings
	}
	return nil
}

type SparseMerkleProof struct {
	// This proof can be used to authenticate whether a given leaf exists in the
	// tree or not. In Rust:
	//   - If this is `Some(HashValue, HashValue)`
	//     - If the first `HashValue` equals requested key, this is an inclusion
	//       proof and the second `HashValue` equals the hash of the
	//       corresponding account blob.
	//     - Otherwise this is a non-inclusion proof. The first `HashValue` is
	//       the only key that exists in the subtree and the second `HashValue`
	//       equals the hash of the corresponding account blob.
	//   - If this is `None`, this is also a non-inclusion proof which indicates
	//     the subtree is empty.
	//
	// In protobuf, this leaf field should either be
	//   - empty, which corresponds to None in the Rust structure.
	//   - exactly 64 bytes, which corresponds to Some<(HashValue, HashValue)>
	//     in the Rust structure.
	Leaf []byte `protobuf:"bytes,1,opt,name=leaf,proto3" json:"leaf,omitempty"`
	// The bitmap indicating which siblings are default. 1 means non-default and
	// 0 means default. The MSB of the first byte corresponds to the sibling at
	// the top of the Sparse Merkle Tree. The rightmost 1-bit of the last byte
	// corresponds to the sibling at the bottom, since this one is always
	// non-default.
	Bitmap []byte `protobuf:"bytes,2,opt,name=bitmap,proto3" json:"bitmap,omitempty"`
	// The non-default siblings. The ones near the root are at the beginning of
	// the list.
	NonDefaultSiblings   [][]byte `protobuf:"bytes,3,rep,name=non_default_siblings,json=nonDefaultSiblings,proto3" json:"non_default_siblings,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SparseMerkleProof) Reset()         { *m = SparseMerkleProof{} }
func (m *SparseMerkleProof) String() string { return proto.CompactTextString(m) }
func (*SparseMerkleProof) ProtoMessage()    {}
func (*SparseMerkleProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{1}
}

func (m *SparseMerkleProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SparseMerkleProof.Unmarshal(m, b)
}
func (m *SparseMerkleProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SparseMerkleProof.Marshal(b, m, deterministic)
}
func (m *SparseMerkleProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SparseMerkleProof.Merge(m, src)
}
func (m *SparseMerkleProof) XXX_Size() int {
	return xxx_messageInfo_SparseMerkleProof.Size(m)
}
func (m *SparseMerkleProof) XXX_DiscardUnknown() {
	xxx_messageInfo_SparseMerkleProof.DiscardUnknown(m)
}

var xxx_messageInfo_SparseMerkleProof proto.InternalMessageInfo

func (m *SparseMerkleProof) GetLeaf() []byte {
	if m != nil {
		return m.Leaf
	}
	return nil
}

func (m *SparseMerkleProof) GetBitmap() []byte {
	if m != nil {
		return m.Bitmap
	}
	return nil
}

func (m *SparseMerkleProof) GetNonDefaultSiblings() [][]byte {
	if m != nil {
		return m.NonDefaultSiblings
	}
	return nil
}

type AccumulatorConsistencyProof struct {
	// The root hashes of the frozen subtrees that form the small accumulator.
	// Note that none of these hashes should be default hash.
	FrozenSubtreeRoots [][]byte `protobuf:"bytes,1,rep,name=frozen_subtree_roots,json=frozenSubtreeRoots,proto3" json:"frozen_subtree_roots,omitempty"`
	// The total number of siblings.
	NumSiblings uint32 `protobuf:"varint,2,opt,name=num_siblings,json=numSiblings,proto3" json:"num_siblings,omitempty"`
	// The non-default siblings. Note that the entire list of siblings always
	// start of zero or more non-default siblings, followed by zero of more
	// default siblings. So given the total number of siblings and the non-default
	// siblings we should be able to construct the entire sibling list.
	NonDefaultSiblings   [][]byte `protobuf:"bytes,3,rep,name=non_default_siblings,json=nonDefaultSiblings,proto3" json:"non_default_siblings,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccumulatorConsistencyProof) Reset()         { *m = AccumulatorConsistencyProof{} }
func (m *AccumulatorConsistencyProof) String() string { return proto.CompactTextString(m) }
func (*AccumulatorConsistencyProof) ProtoMessage()    {}
func (*AccumulatorConsistencyProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{2}
}

func (m *AccumulatorConsistencyProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccumulatorConsistencyProof.Unmarshal(m, b)
}
func (m *AccumulatorConsistencyProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccumulatorConsistencyProof.Marshal(b, m, deterministic)
}
func (m *AccumulatorConsistencyProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccumulatorConsistencyProof.Merge(m, src)
}
func (m *AccumulatorConsistencyProof) XXX_Size() int {
	return xxx_messageInfo_AccumulatorConsistencyProof.Size(m)
}
func (m *AccumulatorConsistencyProof) XXX_DiscardUnknown() {
	xxx_messageInfo_AccumulatorConsistencyProof.DiscardUnknown(m)
}

var xxx_messageInfo_AccumulatorConsistencyProof proto.InternalMessageInfo

func (m *AccumulatorConsistencyProof) GetFrozenSubtreeRoots() [][]byte {
	if m != nil {
		return m.FrozenSubtreeRoots
	}
	return nil
}

func (m *AccumulatorConsistencyProof) GetNumSiblings() uint32 {
	if m != nil {
		return m.NumSiblings
	}
	return 0
}

func (m *AccumulatorConsistencyProof) GetNonDefaultSiblings() [][]byte {
	if m != nil {
		return m.NonDefaultSiblings
	}
	return nil
}

// The complete proof used to authenticate a signed transaction.
type SignedTransactionProof struct {
	LedgerInfoToTransactionInfoProof *AccumulatorProof `protobuf:"bytes,1,opt,name=ledger_info_to_transaction_info_proof,json=ledgerInfoToTransactionInfoProof,proto3" json:"ledger_info_to_transaction_info_proof,omitempty"`
	TransactionInfo                  *TransactionInfo  `protobuf:"bytes,2,opt,name=transaction_info,json=transactionInfo,proto3" json:"transaction_info,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}          `json:"-"`
	XXX_unrecognized                 []byte            `json:"-"`
	XXX_sizecache                    int32             `json:"-"`
}

func (m *SignedTransactionProof) Reset()         { *m = SignedTransactionProof{} }
func (m *SignedTransactionProof) String() string { return proto.CompactTextString(m) }
func (*SignedTransactionProof) ProtoMessage()    {}
func (*SignedTransactionProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{3}
}

func (m *SignedTransactionProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SignedTransactionProof.Unmarshal(m, b)
}
func (m *SignedTransactionProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SignedTransactionProof.Marshal(b, m, deterministic)
}
func (m *SignedTransactionProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedTransactionProof.Merge(m, src)
}
func (m *SignedTransactionProof) XXX_Size() int {
	return xxx_messageInfo_SignedTransactionProof.Size(m)
}
func (m *SignedTransactionProof) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedTransactionProof.DiscardUnknown(m)
}

var xxx_messageInfo_SignedTransactionProof proto.InternalMessageInfo

func (m *SignedTransactionProof) GetLedgerInfoToTransactionInfoProof() *AccumulatorProof {
	if m != nil {
		return m.LedgerInfoToTransactionInfoProof
	}
	return nil
}

func (m *SignedTransactionProof) GetTransactionInfo() *TransactionInfo {
	if m != nil {
		return m.TransactionInfo
	}
	return nil
}

// The complete proof used to authenticate an account state.
type AccountStateProof struct {
	LedgerInfoToTransactionInfoProof *AccumulatorProof  `protobuf:"bytes,1,opt,name=ledger_info_to_transaction_info_proof,json=ledgerInfoToTransactionInfoProof,proto3" json:"ledger_info_to_transaction_info_proof,omitempty"`
	TransactionInfo                  *TransactionInfo   `protobuf:"bytes,2,opt,name=transaction_info,json=transactionInfo,proto3" json:"transaction_info,omitempty"`
	TransactionInfoToAccountProof    *SparseMerkleProof `protobuf:"bytes,3,opt,name=transaction_info_to_account_proof,json=transactionInfoToAccountProof,proto3" json:"transaction_info_to_account_proof,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}           `json:"-"`
	XXX_unrecognized                 []byte             `json:"-"`
	XXX_sizecache                    int32              `json:"-"`
}

func (m *AccountStateProof) Reset()         { *m = AccountStateProof{} }
func (m *AccountStateProof) String() string { return proto.CompactTextString(m) }
func (*AccountStateProof) ProtoMessage()    {}
func (*AccountStateProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{4}
}

func (m *AccountStateProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccountStateProof.Unmarshal(m, b)
}
func (m *AccountStateProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccountStateProof.Marshal(b, m, deterministic)
}
func (m *AccountStateProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountStateProof.Merge(m, src)
}
func (m *AccountStateProof) XXX_Size() int {
	return xxx_messageInfo_AccountStateProof.Size(m)
}
func (m *AccountStateProof) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountStateProof.DiscardUnknown(m)
}

var xxx_messageInfo_AccountStateProof proto.InternalMessageInfo

func (m *AccountStateProof) GetLedgerInfoToTransactionInfoProof() *AccumulatorProof {
	if m != nil {
		return m.LedgerInfoToTransactionInfoProof
	}
	return nil
}

func (m *AccountStateProof) GetTransactionInfo() *TransactionInfo {
	if m != nil {
		return m.TransactionInfo
	}
	return nil
}

func (m *AccountStateProof) GetTransactionInfoToAccountProof() *SparseMerkleProof {
	if m != nil {
		return m.TransactionInfoToAccountProof
	}
	return nil
}

// The complete proof used to authenticate an event.
type EventProof struct {
	LedgerInfoToTransactionInfoProof *AccumulatorProof `protobuf:"bytes,1,opt,name=ledger_info_to_transaction_info_proof,json=ledgerInfoToTransactionInfoProof,proto3" json:"ledger_info_to_transaction_info_proof,omitempty"`
	TransactionInfo                  *TransactionInfo  `protobuf:"bytes,2,opt,name=transaction_info,json=transactionInfo,proto3" json:"transaction_info,omitempty"`
	TransactionInfoToEventProof      *AccumulatorProof `protobuf:"bytes,3,opt,name=transaction_info_to_event_proof,json=transactionInfoToEventProof,proto3" json:"transaction_info_to_event_proof,omitempty"`
	XXX_NoUnkeyedLiteral             struct{}          `json:"-"`
	XXX_unrecognized                 []byte            `json:"-"`
	XXX_sizecache                    int32             `json:"-"`
}

func (m *EventProof) Reset()         { *m = EventProof{} }
func (m *EventProof) String() string { return proto.CompactTextString(m) }
func (*EventProof) ProtoMessage()    {}
func (*EventProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_473d204b28f447f0, []int{5}
}

func (m *EventProof) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EventProof.Unmarshal(m, b)
}
func (m *EventProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EventProof.Marshal(b, m, deterministic)
}
func (m *EventProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventProof.Merge(m, src)
}
func (m *EventProof) XXX_Size() int {
	return xxx_messageInfo_EventProof.Size(m)
}
func (m *EventProof) XXX_DiscardUnknown() {
	xxx_messageInfo_EventProof.DiscardUnknown(m)
}

var xxx_messageInfo_EventProof proto.InternalMessageInfo

func (m *EventProof) GetLedgerInfoToTransactionInfoProof() *AccumulatorProof {
	if m != nil {
		return m.LedgerInfoToTransactionInfoProof
	}
	return nil
}

func (m *EventProof) GetTransactionInfo() *TransactionInfo {
	if m != nil {
		return m.TransactionInfo
	}
	return nil
}

func (m *EventProof) GetTransactionInfoToEventProof() *AccumulatorProof {
	if m != nil {
		return m.TransactionInfoToEventProof
	}
	return nil
}

func init() {
	proto.RegisterType((*AccumulatorProof)(nil), "types.AccumulatorProof")
	proto.RegisterType((*SparseMerkleProof)(nil), "types.SparseMerkleProof")
	proto.RegisterType((*AccumulatorConsistencyProof)(nil), "types.AccumulatorConsistencyProof")
	proto.RegisterType((*SignedTransactionProof)(nil), "types.SignedTransactionProof")
	proto.RegisterType((*AccountStateProof)(nil), "types.AccountStateProof")
	proto.RegisterType((*EventProof)(nil), "types.EventProof")
}

func init() { proto.RegisterFile("proof.proto", fileDescriptor_473d204b28f447f0) }

var fileDescriptor_473d204b28f447f0 = []byte{
	// 411 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x54, 0xc1, 0x6a, 0xdb, 0x40,
	0x10, 0x45, 0x76, 0x9a, 0xc3, 0xd8, 0xa5, 0x89, 0x08, 0xae, 0x69, 0x28, 0x75, 0x0c, 0x05, 0x9f,
	0x4c, 0x48, 0xbf, 0xc0, 0xb4, 0x3d, 0xf4, 0x50, 0x28, 0x2b, 0x1f, 0x5b, 0x96, 0x95, 0x3c, 0x72,
	0x45, 0xa5, 0x19, 0x75, 0x77, 0x54, 0x48, 0xbf, 0xa4, 0x1f, 0x90, 0x5f, 0xe9, 0x7f, 0x15, 0xed,
	0xaa, 0x44, 0x91, 0x1b, 0x0a, 0xb9, 0xe5, 0xa6, 0x9d, 0xc7, 0xbe, 0x37, 0xef, 0x3d, 0xb1, 0x30,
	0xa9, 0x2d, 0x73, 0xbe, 0xae, 0x2d, 0x0b, 0xc7, 0x4f, 0xe4, 0xba, 0x46, 0xf7, 0x62, 0x26, 0xd6,
	0x90, 0x33, 0x99, 0x14, 0x4c, 0xba, 0xa0, 0x9c, 0x03, 0xbc, 0xfc, 0x0c, 0x27, 0x9b, 0x2c, 0x6b,
	0xaa, 0xa6, 0x34, 0xc2, 0xf6, 0x53, 0x7b, 0x31, 0x9e, 0xc1, 0x71, 0x5a, 0x48, 0x65, 0xea, 0x79,
	0xb4, 0x88, 0x56, 0x47, 0xaa, 0x3b, 0xc5, 0x97, 0x70, 0x46, 0x4c, 0x7a, 0x87, 0xb9, 0x69, 0x4a,
	0xd1, 0xae, 0x48, 0xcb, 0x82, 0xf6, 0x6e, 0x3e, 0x5a, 0x8c, 0x57, 0x53, 0x15, 0x13, 0xd3, 0xbb,
	0x00, 0x25, 0x1d, 0xb2, 0xfc, 0x0e, 0xa7, 0x49, 0x6d, 0xac, 0xc3, 0x8f, 0x68, 0xbf, 0x95, 0x18,
	0xe8, 0x63, 0x38, 0x2a, 0xd1, 0xe4, 0x9e, 0x7c, 0xaa, 0xfc, 0x77, 0x4f, 0x72, 0xe4, 0xa7, 0xff,
	0x93, 0x1c, 0xdf, 0x2b, 0x79, 0x13, 0xc1, 0x79, 0xcf, 0xd1, 0x5b, 0x26, 0x57, 0x38, 0x41, 0xca,
	0xae, 0x83, 0xfa, 0x25, 0x9c, 0xe5, 0x96, 0x7f, 0x22, 0x69, 0xd7, 0xa4, 0x62, 0x11, 0xb5, 0x65,
	0x16, 0x37, 0x8f, 0x02, 0x63, 0xc0, 0x92, 0x00, 0xa9, 0x16, 0x89, 0x2f, 0x60, 0x4a, 0x4d, 0xd5,
	0xb7, 0x1b, 0xad, 0x9e, 0xaa, 0x09, 0x35, 0xd5, 0x5f, 0xd1, 0x07, 0xac, 0xf9, 0x3b, 0x82, 0x59,
	0x52, 0xec, 0x09, 0x77, 0xdb, 0xdb, 0x62, 0xc2, 0x86, 0x5f, 0xe1, 0x75, 0x89, 0xbb, 0x3d, 0x5a,
	0xdf, 0x93, 0x16, 0xd6, 0xc3, 0xee, 0xb4, 0x2f, 0xd8, 0x07, 0x38, 0xb9, 0x7a, 0xbe, 0xf6, 0x0d,
	0xaf, 0x87, 0x35, 0xaa, 0x45, 0x60, 0xf9, 0x40, 0x39, 0x6f, 0xb9, 0xa7, 0xd2, 0x0e, 0x82, 0xd2,
	0x06, 0x4e, 0x86, 0xd4, 0xde, 0xdd, 0xe4, 0x6a, 0xd6, 0x91, 0x0e, 0xae, 0xa9, 0x67, 0x72, 0x77,
	0xb0, 0xbc, 0x19, 0xc1, 0xe9, 0x26, 0xcb, 0xb8, 0x21, 0x49, 0xc4, 0x08, 0x3e, 0x3e, 0x0b, 0x71,
	0x0a, 0x17, 0x07, 0xdb, 0x09, 0x6b, 0x13, 0x5c, 0x75, 0x8b, 0x8e, 0x3d, 0xe7, 0xbc, 0xe3, 0x3c,
	0xf8, 0xa9, 0xd5, 0xcb, 0x01, 0xeb, 0x96, 0xbb, 0x54, 0x3c, 0xbc, 0xfc, 0x35, 0x02, 0x78, 0xff,
	0x03, 0xbb, 0xe3, 0xe3, 0xca, 0xe7, 0x0b, 0xbc, 0xfa, 0x57, 0x3e, 0xd8, 0xda, 0xb9, 0x93, 0xce,
	0xbd, 0x6b, 0x9e, 0x1f, 0x84, 0x73, 0x9b, 0x45, 0x7a, 0xec, 0x1f, 0xa2, 0x37, 0x7f, 0x02, 0x00,
	0x00, 0xff, 0xff, 0x8b, 0x40, 0x36, 0xeb, 0xb6, 0x04, 0x00, 0x00,
}
